// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"
)

const createDriver = `-- name: CreateDriver :exec
INSERT INTO driver (id)
VALUES ($1)
`

func (q *Queries) CreateDriver(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, createDriver, id)
	return err
}

const createTemporaryUser = `-- name: CreateTemporaryUser :one
INSERT INTO users (phone, temporary)
VALUES ($1, true)
RETURNING id
`

func (q *Queries) CreateTemporaryUser(ctx context.Context, phone string) (int32, error) {
	row := q.db.QueryRow(ctx, createTemporaryUser, phone)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, phone, email, password, device_token, temporary)
VALUES ($1, $2, $3, $4 ,$5, false)
RETURNING id, name, phone, email, password, device_token, temporary, rate_total, rates, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Name        *string `json:"name"`
	Phone       string  `json:"phone"`
	Email       *string `json:"email"`
	Password    *string `json:"password"`
	DeviceToken *string `json:"device_token"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Password,
		arg.DeviceToken,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.DeviceToken,
		&i.Temporary,
		&i.RateTotal,
		&i.Rates,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDeviceTokenByUserID = `-- name: GetDeviceTokenByUserID :one
SELECT device_token
FROM users
WHERE id = $1
`

func (q *Queries) GetDeviceTokenByUserID(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getDeviceTokenByUserID, id)
	var device_token *string
	err := row.Scan(&device_token)
	return device_token, err
}

const getDriverById = `-- name: GetDriverById :one
SELECT id, status, created_at, updated_at, deleted_at
FROM driver WHERE id = $1
`

func (q *Queries) GetDriverById(ctx context.Context, id int32) (Driver, error) {
	row := q.db.QueryRow(ctx, getDriverById, id)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrCreateTempUser = `-- name: GetOrCreateTempUser :one
WITH existing_user AS (
    SELECT id, name, phone, email, password, device_token, temporary, rate_total, rates, created_at, updated_at, deleted_at FROM users WHERE phone = $1
)
INSERT INTO users (phone, temporary)
SELECT $1, true
WHERE NOT EXISTS (SELECT 1 FROM existing_user)
RETURNING id, name, phone, email, password, device_token, temporary, rate_total, rates, created_at, updated_at, deleted_at
`

func (q *Queries) GetOrCreateTempUser(ctx context.Context, phone string) (User, error) {
	row := q.db.QueryRow(ctx, getOrCreateTempUser, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.DeviceToken,
		&i.Temporary,
		&i.RateTotal,
		&i.Rates,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, phone, email, password, device_token, temporary, rate_total, rates, created_at, updated_at, deleted_at
FROM users WHERE email = $1 AND email IS NOT NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email *string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.DeviceToken,
		&i.Temporary,
		&i.RateTotal,
		&i.Rates,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id
FROM users WHERE phone = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone string) (int32, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phone)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateDeviceTokenByUserID = `-- name: UpdateDeviceTokenByUserID :exec
UPDATE users
SET device_token = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateDeviceTokenByUserIDParams struct {
	ID          int32   `json:"id"`
	DeviceToken *string `json:"device_token"`
}

func (q *Queries) UpdateDeviceTokenByUserID(ctx context.Context, arg UpdateDeviceTokenByUserIDParams) error {
	_, err := q.db.Exec(ctx, updateDeviceTokenByUserID, arg.ID, arg.DeviceToken)
	return err
}
